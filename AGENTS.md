# Repository Guide for AI Agents

This document provides a comprehensive overview of this homelab infrastructure repository. It is designed to help AI agents understand the stack, structure, and operational workflows.

## 1. Project Overview

This repository manages a homelab infrastructure running on two Lenovo M920q nodes using Proxmox VE. The stack automates the provisioning of Virtual Machines (VMs), the installation of a K3s Kubernetes cluster, and the deployment of applications using GitOps.

**Tech Stack:**
- **Hypervisor:** Proxmox VE
- **Provisioning:** Terraform (Proxmox provider `bpg/proxmox`)
- **Configuration Management:** Ansible (via `uvx`)
- **Container Orchestration:** K3s
- **GitOps:** Argo CD
- **Secrets Management:** Bitnami Sealed Secrets

## 2. Directory Structure & Responsibilities

### `terraform/` (Infrastructure Layer)
- **Scope:** Manages Proxmox VMs, cloud-init configurations, and networking.
- **Provider:** Uses `bpg/proxmox`.
- **Key File:** `terraform/proxmox/main.tf` defines the VM resources.
- **Output:** Generates `terraform/proxmox/inventory.ini` automatically for Ansible to use.
- **Variables:** `variables.tf` (schema) and `terraform.tfvars` (values/secrets).

### `ansible/` (OS & Cluster Layer)
- **Scope:** Installs and configures K3s on the provisioned VMs.
- **Execution:** Uses `uvx` to run Ansible without global dependencies.
- **Key Path:** `ansible/k3s/` contains the playbooks.
- **Inventory:** Consumes the `inventory.ini` generated by Terraform.
- **Playbooks:**
  - `install-k3s.yaml`: Bootstraps the cluster.
  - `uninstall-k3s.yaml`: Tears it down.

### `kubernetes/` (Application Layer)
- **Scope:** Kubernetes manifests managed via GitOps (Argo CD).
- **Structure:**
  - `bootstrap/`: Initial setup manifests.
    - `argocd/`: Contains the Argo CD installation manifests and the root `ApplicationSet`.
  - `core/`: Critical infrastructure services (e.g. MetalLB, Sealed Secrets).
  - `apps/`: End-user applications (Immich, Vaultwarden, etc.).

## 3. Operational Workflow

To build the cluster from scratch, the following order of operations is required:

1.  **Terraform:**
    - Run `terraform apply` in `terraform/proxmox/`.
    - **Result:** VMs created, started, and `inventory.ini` generated.

2.  **Ansible:**
    - Ensure SSH agent is running (`eval "$(ssh-agent -s)" && ssh-add <key>`).
    - Run `uvx --from ansible-core ansible-playbook install-k3s.yaml` in `ansible/k3s/`.
    - **Result:** K3s cluster installed and running.

3.  **Kubeconfig Retrieval:**
    - SSH into the control plane node to retrieve `/etc/rancher/k3s/k3s.yaml`.
    - Update the server IP in the config file.

4.  **Bootstrap GitOps:**
    - Run `kubectl apply -k kubernetes/bootstrap/argocd`.
    - **Result:** Argo CD installs and immediately detects the `ApplicationSet`, which then syncs the rest of the repository (`core` and `apps` folders).

## 4. Key Conventions & Configuration

- **Usernames:** Default VM user is defined in Terraform variables (often `debian` or similar).
- **Networking:**
  - MetalLB is used for LoadBalancer services.
  - IP pools are defined in `kubernetes/core/metallb-config/`.
- **Storage:**
  - Local Path Provisioner (standard K3s).
  - NFS Provisioner available in `kubernetes/core/nfs-provisioner/`.
- **Database:**
  - CloudNativePG is the standard operator for Postgres databases (`kubernetes/core/cloudnative-pg/`).

## 5. Do's and Don'ts for Agents

- **DO** checks `terraform/proxmox/inventory.ini` existence before trying to run Ansible.
- **DO** read `README.md` in subdirectories for specific command syntax.
- **DO NOT** hardcode IP addresses; refer to Terraform variables or Ansible inventory.
- **DO NOT** commit `terraform.tfvars` or `kubeconfig` files.

## 6. K3s-Specific Information

### Namespace Management

Namespaces are created **automatically** by Argo CD based on the directory name within `kubernetes/apps/` and `kubernetes/core/`.

- Each subdirectory of `apps/` and `core/` maps directly to a Kubernetes namespace of the same name.
- **Example:** `kubernetes/apps/adguard/` → namespace `adguard`; `kubernetes/core/metallb/` → namespace `metallb`.
- You do **not** need to create a `Namespace` manifest manually — Argo CD handles this via the `CreateNamespace=true` sync option on the root `ApplicationSet`.
- When adding a new application, simply create a new folder with the desired namespace name under `apps/` or `core/` and place the manifests inside it.