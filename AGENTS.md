# Repository Guide for AI Agents

This document provides a comprehensive overview of this homelab infrastructure repository. It is designed to help AI agents understand the stack, structure, and operational workflows.

## 1. Project Overview

This repository manages a homelab infrastructure running on two Lenovo M920q nodes using Proxmox VE. The stack automates the provisioning of Virtual Machines (VMs), the installation of a K3s Kubernetes cluster, and the deployment of applications using GitOps.

**Tech Stack:**
- **Hypervisor:** Proxmox VE
- **Provisioning:** Terraform (Proxmox provider `bpg/proxmox`)
- **Configuration Management:** Ansible (via `uvx`)
- **Container Orchestration:** K3s
- **GitOps:** Argo CD
- **Secrets Management:** Bitnami Sealed Secrets
- **Ingress:** Traefik
- **TLS:** cert-manager (Let's Encrypt)
- **Database:** CloudNativePG (PostgreSQL)

## 2. Directory Structure & Responsibilities

### `terraform/` (Infrastructure Layer)
- **Scope:** Manages Proxmox VMs, cloud-init configurations, and networking.
- **Provider:** Uses `bpg/proxmox`.
- **Key File:** `terraform/proxmox/main.tf` defines the VM resources.
- **Output:** Generates `terraform/proxmox/inventory.ini` automatically for Ansible to use.
- **Variables:** `variables.tf` (schema) and `terraform.tfvars` (values/secrets).

### `ansible/` (OS & Cluster Layer)
- **Scope:** Installs and configures K3s on the provisioned VMs.
- **Execution:** Uses `uvx` to run Ansible without global dependencies.
- **Key Path:** `ansible/k3s/` contains the playbooks.
- **Inventory:** Consumes the `inventory.ini` generated by Terraform.
- **Playbooks:**
  - `install-k3s.yaml`: Bootstraps the cluster (control plane + workers).
  - `install-prereqs.yaml`: Installs additional packages on existing VMs without needing to reprovision. Useful for adding dependencies after initial setup (some packages like `open-iscsi` and `nfs-common` are also installed via cloud-init during VM creation).
  - `uninstall-k3s.yaml`: Tears down the cluster.

### `kubernetes/` (Application Layer)
- **Scope:** Kubernetes manifests managed via GitOps (Argo CD).
- **Structure:**
  - `bootstrap/`: Initial setup manifests.
    - `argocd/`: Contains the Argo CD installation manifests and the root `ApplicationSet` resources.
  - `core/`: Critical infrastructure services:
    - `cert-manager/`: TLS certificate management with Let's Encrypt ClusterIssuer.
    - `cloudnative-pg/`: CloudNativePG operator installation.
    - `databases/`: Shared PostgreSQL cluster (`postgres-shared`) with S3 backups via Barman.
    - `metallb-install/` and `metallb-config/`: MetalLB installation and IP pool configuration.
    - `monitoring/`: Cluster monitoring (kube-prometheus-stack Helm chart).
    - `nfs-provisioner/`: NFS-backed dynamic StorageClass.
    - `sealed-secrets/`: Sealed Secrets controller.
    - `traefik/`: Traefik ingress controller TLS configuration (certificate, default TLS store).
  - `apps/`: End-user applications (Home Assistant, Homepage, HortusFox, Immich, Jellyfin, Linkding, Mealie, Paperless-ngx, Vaultwarden, Vikunja).

## 3. Operational Workflow

To build the cluster from scratch, the following order of operations is required:

1.  **Terraform:**
    - Run `terraform apply` in `terraform/proxmox/`.
    - **Result:** VMs created, started, and `inventory.ini` generated.

2.  **Ansible:**
    - Ensure SSH agent is running (`eval "$(ssh-agent -s)" && ssh-add <key>`).
    - Run `uvx --from ansible-core ansible-playbook install-k3s.yaml` in `ansible/k3s/`.
    - **Result:** K3s cluster installed and running.

3.  **Kubeconfig Retrieval:**
    - SSH into the control plane node to retrieve `/etc/rancher/k3s/k3s.yaml`.
    - Update the server IP in the config file.

4.  **Bootstrap GitOps:**
    - Run `kubectl apply -k kubernetes/bootstrap/argocd`.
    - **Result:** Argo CD installs and immediately detects the `ApplicationSet` resources, which then sync the rest of the repository (`core` and `apps` folders).

## 4. Key Conventions & Configuration

- **VM User:** The default VM user is configured via the `ssh_user` Terraform variable (see `terraform/proxmox/variables.tf`).
- **Networking:**
  - MetalLB is used for LoadBalancer services.
  - IP pools are defined in `kubernetes/core/metallb-config/`.
  - Traefik handles ingress routing; TLS certificates are issued by cert-manager.
- **Storage:**
  - Local Path Provisioner (standard K3s default StorageClass).
  - NFS Provisioner available in `kubernetes/core/nfs-provisioner/`.
- **Database:**
  - CloudNativePG is the standard operator for Postgres databases (`kubernetes/core/cloudnative-pg/`).
  - A shared cluster `postgres-shared` in namespace `databases` serves multiple apps (`kubernetes/core/databases/`).
  - Immich maintains its own dedicated CNPG cluster in its app directory (`kubernetes/apps/immich/postgres/`).
  - Backups use Barman with S3-compatible object storage on the NAS.
- **Secrets:**
  - Secrets are encrypted using Bitnami Sealed Secrets and stored in Git as `*sealed-secrets.yaml` files.
  - To create a sealed secret: `kubeseal --controller-namespace sealed-secrets --format yaml < secret.yaml > sealed-secret.yaml`.
  - Plaintext `*secrets*.yaml` files are excluded from Git via `.gitignore`.
- **App Deployment Patterns:**
  - Most apps use raw Kustomize manifests (deployment, service, ingress, PVC).
  - Some apps (Immich, Vikunja) use Kustomize with embedded Helm charts (`helmCharts` in `kustomization.yaml`).
  - A few (Jellyfin, monitoring) use standalone Helm charts (`Chart.yaml` + `values.yaml`).

## 5. Do's and Don'ts for Agents

- **DO** check `terraform/proxmox/inventory.ini` existence before trying to run Ansible.
- **DO** read `README.md` in subdirectories for specific command syntax.
- **DO** use Sealed Secrets for any new secret — never commit plaintext secrets.
- **DO NOT** hardcode IP addresses; refer to Terraform variables or Ansible inventory.
- **DO NOT** commit `terraform.tfvars` or `kubeconfig` files.

## 6. K3s-Specific Information

### Namespace Management

Namespaces are created **automatically** by Argo CD based on the directory name within `kubernetes/apps/` and `kubernetes/core/`.

- Each subdirectory of `apps/` and `core/` maps directly to a Kubernetes namespace of the same name.
- **Example:** `kubernetes/apps/adguard/` → namespace `adguard`; `kubernetes/core/metallb/` → namespace `metallb`.
- You do **not** need to create a `Namespace` manifest manually — Argo CD handles this via the `CreateNamespace=true` sync option on the root `ApplicationSet`.
- When adding a new application, simply create a new folder with the desired namespace name under `apps/` or `core/` and place the manifests inside it.
